<section>
        <h2>Manipulating the DOM</h2>
        <pre><code>var div = document.getElementById('findMe');
div.getAttribute('class');

//by principle of least surprise, what's the method
//to set an attribute?
</code></pre>
      <pre class="fragment"><code>div.setAttribute('class', 'nav');</code></pre>
      <pre class="fragment"><code>div.style.backgroundColor = "red";</code></pre>
      <pre class="fragment"><code>div.innerText = 'Bye'; //replaced!
div.innerHTML += '&lt;p&gt;New Paragraph Element&lt;/p&gt; //appended!</code></pre>
      </section>
      <section>
        <h2>Manipulating the DOM</h2>
        <pre class="fragment"><code>var newDiv = document.createElement('div');
newDiv.innerText = "I am a new div!";
document.body.appendChild(newDiv);</code></pre>
        <pre class="fragment"><code>var newParagraph = document.createElement('p');
var paragraphText = document.createTextNode('New Paragraph!');
newParagraph.appendChild(paragraphText);
document.body.appendChild(newParagraph);</code></pre>
      </section>
<section>
        <h2>DOM Exercise</h2>
        <ul>
          <li>Create a link on a page. When clicked, prompt for a person's name, favorite color, and favorite number.</li>
          <li>Dynamically create a paragraph element displaying their name</li>
          <li>If their favorite number is odd, color their name text their favorite color. If it's even, color the paragraph background their favorite color.</li>
        </ul>
      </section>
<section>
        <h2>Debugging Lab</h2>
        <p>We're going to put everything you've learned so far today to work in this debugging lab. Run the example code, find the errors, and make the program work. You'll need to pay attention to syntax, logic, scope, and everything else we've looked at today to solve it. Good luck!</p>
      </section>
      <section>
        <h2>Questions?</h2>
      </section>
      <section>
        <h2>Advanced Topics</h2>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <p><small>Arrow functions are an ES6 feature that provides a new syntax and some new behavior to JavaScript functions.</small></p>
        <pre class="fragment"><code>var arrowFunction = () => {
  console.log('I was called!')
}

var regularFunction = function() {
  console.log('I was called, too!')
}

arrowFunction() // 'I was called!'
regularFunction() // 'I was called, too!'</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <h4>Arguments</h4>
        <pre class="fragment"><code>var arrowFunction = (arg1, arg2) => {
  console.log(arg1, arg2)
}

arrowFunction('Hey,', 'you!') // 'Hey, you!'

//if only one arg, you can leave off the parens
var singleArgFunction = arg1 => {
  console.log(arg1)
}

singleArgFunction("hi!")</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <h4>Implicit Return</h4>
        <pre class="fragment"><code>function square(x) {
  return x*x;
}

var arrowSquare = n => n*n
//only with no body block

square(4) // 16
arrowSquare(4) // 16</code></pre>
      </section>
      <section>
        <h2>Arrow Function Exercise</h2>
        <p>Write an arrow function that takes a string argument and returns the reversed string.</p>
      </section>
      <section>
        <h2>Hoisting</h2>
        <p>Hoisting is a fancy way of saying that JavaScript will move function and variable declarations to the top of their scope before code execution.</p>
        <p class="fragment"><em>Declarations</em>, not assignments</p>
        <pre class="fragment"><code>//when we write
var x = 0;
//javascript sees
var x;
x = 0;</code></pre>
      </section>
      <section>
        <h2>Hoisting</h2>
        <pre class="fragment"><code>console.log(hoisted); //what happens?</code></pre>
        <pre class="fragment"><code>console.log(hoisted);

var hoisted = "hi"; //what happens?</code></pre>
        <pre class="fragment"><code>var hoisted; //declaration hoisted to top of scope
console.log(hoisted);
hoisted = "hi";</code></pre>
<pre class="fragment"><code>function myFunction(){
  console.log(word)
  var word = "cake";
}//what happens when we myFunction()?</code></pre>
      <aside class="notes">remind function scope</aside>
      </section>
      <section>
        <h2>Function Hoisting</h2>
        <pre class="fragment"><code>eat();

function eat(){
  console.log("time to eat cake!")
} //whole function hoisted</code></pre>
      <pre class="fragment"><code>eat();

var eat = function() {
  console.log("time to eat cake!")
}</code></pre>
      </section>
      <section>
        <h2>Hoisting Danger</h2>
        <pre class="fragment"><code>var snack = "granola bar";
function eat(){
  console.log(snack);
  var snack = "snickers";
}
eat();</code></pre>
        <p class="fragment">Most problems can be avoided by using good naming and good organization practices, and <code>let</code> and <code>const</code> rather than <code>var</code></p>
        <aside class="notes">it re-declared var.</aside>
      </section>
<section>
        <h2>XMLHttpRequest (XHR)</h2>
        <ul>
          <li class="fragment">Basic (and oldest, hence "XML") JS client/server API.</li>
          <li class="fragment">Event-based Architecture.</li>
          <li class="fragment">Built around a request/response object model.</li>
        </ul>
      </section>
      <section>
        <h2>Getting Data with XHR</h2>
        <p><small>Let's use XHR to explore the Github API. https://developer.github.com/v3/repos/#list-user-repositories</small></p>
        <pre class="fragment"><code>//type in network tab
// get new XHR request object
const req = new HMLHttpRequest()
// "open" (but don't activate) request
req.open("GET", 'https://api.github.com/users/octocat/repos')
// execute the request
req.send()</code></pre>
      <aside class="notes">explore network tab, explore gh api a little</aside>
      </section>
      <section>
        <h4>Handling XHR Responses</h4>
        <pre class="fragment"><code>function showRepositories(event, data) {
  //"this" = XMLHttpRequest object that fired the event
  console.log(this);
  //console.log(this.responseText)
}

function getRepositories() {
  const req = new XMLHttpRequest()
  req.addEventListener("load", showRepositories);
  //what is showRepositories?
  req.open("GET", 'https://api.github.com/users/octocat/repos')
  req.send()
}</code></pre>
      <pre class="fragment"><code>function showRepositories(event, data) {
  console.log(JSON.parse(this.responseText));
}</code></pre>
      </section>
      <section>
        <h2>XHR Exercise</h2>
        <p>Using XHR to explore the Github API, write a set of functions that:</p>
        <ol>
          <li>Lists all public repositories</li>
          <li>Lists the first five commits for each repository</li>
        </ol>
      </section>
      <section>
        <h2>XHR Limitations</h2>
        <ul>
          <li>Event model restrictive</li>
          <li>Very low-level</li>
          <li>Not natively JSON-aware</li>
        </ul>
      </section>

      <section>
        <h2>Arrow Functions</h2>
        <p><small>Arrow functions are an ES6 feature that provides a new syntax and some new behavior to JavaScript functions.</small></p>
        <pre class="fragment"><code>var arrowFunction = () => {
  console.log('I was called!')
}

var regularFunction = function() {
  console.log('I was called, too!')
}

arrowFunction() // 'I was called!'
regularFunction() // 'I was called, too!'</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <h4>Arguments</h4>
        <pre class="fragment"><code>var arrowFunction = (arg1, arg2) => {
  console.log(arg1, arg2)
}

arrowFunction('Hey,', 'you!') // 'Hey, you!'

//if only one arg, you can leave off the parens
var singleArgFunction = arg1 => {
  console.log(arg1)
}

singleArgFunction("hi!")</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <h4>Implicit Return</h4>
        <pre class="fragment"><code>function square(x) {
  return x*x;
}

var arrowSquare = n => n*n
//only with no body block

square(4) // 16
arrowSquare(4) // 16</code></pre>
      </section>
      <section>
        <h4>Arrow Functions and Promises</h4>
        <pre class="fragment"><code>order('Shack Burger')
  .then(function(order) { //order = returned val from order
    finishedOrder = order.prepare()
    return finishedOrder //pass this down the chain
  })
  .then(function(food) { //food = returned val from last then
    serve(food)
  })
  .catch(function(err) {
    console.log("oops")
  })</code></pre>
  <pre class="fragment"><code>order('Shack Burger')
  .then(order => order.prepare()) //implicit return
  .then(food => serve(food))
  .catch(err => { console.log("oops") })</code></pre>
      </section>
      <section>
        <h2>Which Leads Us To</h2>
        <pre class="fragment"><code>fetch('https://api.github.com/repos/jquery/jquery/commits')
  .then(resp => resp.json())
  .then(json => console.log(json));</code></pre>
      </section>
      <section>
        <h2>Fetch API</h2>
        <pre><code>fetch('https://api.github.com/repos/jquery/jquery/commits')
  .then(resp => resp.json())
  .then(json => console.log(json));</code></pre>
        <small><ul>
          <li class="fragment">Built from the ground up to handle modern web needs, like JSON and streaming.</li>
          <li class="fragment"><code>fetch()</code>is a global function. No making XHR objects.</li>
          <li class="fragment">Promise-based.</li>
          <li class="fragment">Body <em>mixin</em> provides parsing.</li>
          <li class="fragment">Not supported in IE OF COURSE BECAUSE WHY HAVE NICE THINGS</li>
        </ul></small>
      </section>
      <section>
        <h2>Authenticated Fetch</h2>
        <pre class="fragment"><code>const token = 'YOUR_TOKEN_HERE'
fetch('https://api.github.com/user/repos', {
  headers: {
    Authorization: `token ${token}`
  }
}).then(res => res.json()).then(json => console.log(json));</code></pre>
      </section>



<section>
        <h2>Handlebars</h2>
        <p>Building HTML by hand sucks. Template engines give us a way to dynamically create HTML without having to always do it by hand.</p>
        <pre class="fragment"><code><main id="main">
  <a href="#" onclick="loadIssues();">Load Github Issue</a>
</main>
&lt;script id="issue-template" type="text/x-handlebars-template"&gt;
  &lt;article&gt;
    &lt;header&gt;&lt;h3&gt;Issue #{{number}} ({{state}})&lt;/h3&gt;&lt;/header&gt;
    &lt;p&gt;{{body}}&lt;/p&gt;
    &lt;footer&gt;&lt;a href="{{url}}"&gt;created {{created_at}}&lt;/a&gt;&lt;/footer&gt;
  &lt;/article&gt;
&lt;/script&gt;</code></pre>
        <aside class="notes">handlebarsjs.com</aside>
      </section>
      <section>
        <h2>Handlebars</h2>
        <pre><code>function loadIssue() {
  var issue = {
    state: "closed",
    number: 5,
    created_at: "2017-03-31 16:23:13 UTC",
    body: "Instructions say GET but it's a POST"
  }

  var template = Handlebars.compile(document.getElementById("issue-template").innerHTML);
  var result = template(issue);
  document.getElementsByTagName("main")[0].innerHTML += result;
}</code></pre>
      <aside class="notes">fake our own data to test before calling api. wire it up and go!</aside>
      </section>
      <section>
        <h2>Handlebars Helpers</h2>
        <h4>{{each}}</h4>
        <pre class="fragment"><code><script id="issue-template" type="text/x-handlebars-template">
  {{#each this}}
  <article>
    <header><h3>Issue #{{number}} ({{state}})</h3></header>
    <p>{{body}}</p>
    <footer><a href="{{url}}">created {{created_at}}</a></footer>
  </article>
  {{/each}}
</script></code></pre>
      <pre class="fragment"><code>function loadIssues() {
  var template = Handlebars.compile(document.getElementById("issue-template").innerHTML);
  var result = template(issues);
  document.getElementsByTagName("main")[0].innerHTML += result;
}</code></pre>
      <aside class="notes">block-level helper. need # and / to mark start and end like braces or tags</aside>
      </section>
      <section>
        <h2>Handlebars Helpers</h2>
        <h4>{{if}}</h4>
        <pre class="fragment"><code><script id="issue-template" type="text/x-handlebars-template">
  {{#each this}}
  <article>
    <header><h3>Issue #{{number}} ({{state}})</h3></header>
    <p>{{body}}</p>
    {{#if comments_count}}
    <p>{{comments_count}} Comments</p>
    {{else}}
    <p>No Comments Yet</p>
    {{/if}}
    <footer><a href="{{url}}">created {{created_at}}</a></footer>
  </article>
  {{/each}}
</script></code></pre>
      <aside class="notes">You'll notice this isn't a full expression like you might use in a regular if statement. You can only give if a value from the context object, and if that value evaluates falsy (false, undefined, null, 0, "", or []) then Handlebars won't render the block. In this case, since comments_count is an integer, we can rely on a zero-comments object not rendering this block.</aside>
      </section>

      <section>
        <h2>Asynchronous Operations</h2>
        <p>Asynchronous code allows you to "kick off" an operation and then let the program continue without waiting for that operation to complete. Some uses for asynchronous code:</p>
        <ul>
          <li class="fragment">Long-running operations like reading or generating big data sets.</li>
          <li class="fragment">Operations that cross system boundaries or require external resources.</li>
          <li class="fragment">Operations that don't need to complete before the user moves on to other tasks.</li>
        </ul>
      </section>
      <section>
        <h4>setTimeout()</h4>
        <p>The setTimeout() function sets a timer that executes the specified callback function after the timer expires.</p>
        <pre class="fragment"><code>var timeoutID;
function slowAlert() {
  alert('That was really slow!');
}

function clearAlert() {
  //cancels the timer
  window.clearTimeout(timeoutID);
}

// hold a reference to the timer if we need to cancel
timeoutID = window.setTimeout(slowAlert, 2000);
// with anon func instead of callback
window.setTimeout(function() {
    alert('That was really slow!');
}, 2000);
</code></pre>
      <aside class="notes">more readable with callbacks</aside>
      </section>
      <section>
        <h4>setInterval()</h4>
        <p>The setInterval() function repeatedly calls a function with a fixed time delay between each call.</p>
        <pre class="fragment"><code>&lt;div id='box'&gt;Hello&lt;/div&gt;

var intervalId;
function changeColor() {
  intervalId = setInterval(flashText, 1000);
}

function flashText() {
  var box = document.getElementById('box');
  //what operator?
  box.style.color = box.style.color == 'red' ? 'blue' : 'red';
}

function stopTextColor() {
  clearInterval(intervalId);
}</code></pre>
      </section>
      <section>
        <h2>Async Lab</h2>
        <small><p>Let's make a whammy game!</p>
        <ul>
          <li>Make an HTML page with a Start and Stop button. Create an array of prize amounts and "whammies" (e.g. [100, 200, 300, 400, 500, "Whammy!"])</li>
          <li>When the player clicks Start, kick off a function to randomly generate a number that's a valid index in your array (i.e. if your array has 10 items, a number between 0 and 9). Live-update the page with the current prize amount.</li>
          <li>When the player clicks Stop, cancel the game timer and show them what they've won! Or lost!</li>
          <li>Keep a running total of the score that gets wiped out if you land on Whammy.</li>
        </ul></small>
        <aside class="notes">The faster it goes, the harder it is!</aside>
      </section>

            <section>
        <h2>Functions Review</h2>
        <pre class="fragment"><code>function say(x) {
  console.log(x);
}</code></pre>
        <ul>
          <li class="fragment">Functions are data.</li>
          <li class="fragment">Functions are portable.</li>
        </ul>
          <pre class="fragment"><code>let func = function(x) {
  console.log(x);
}
func("hi");</code></pre>
      <aside class="notes">say vs say()</aside>
      </section>
      <section>
        <h2>Functions as Arguments</h2>
        <pre class="fragment"><code>let add = function(x,y) {
  return x+y;
}
let subtract = function(x,y) {
  return x-y;
}
let doMath = function(x,y,mathFunction) {
  return mathFunction(x,y);
}
doMath(3,2,add);
doMath(3,2,subtract);</code></pre>
      </section>
      <section>
        <h2>Callback Functions</h2>
        <p>Callback Functions are used to provide a way for an active function to pass its results to another function, often after a long-running or asynchronous operation.</p>
        <pre class="fragment"><code>let finished = function(data) {
    console.log(data);
}
let startOperation = function(done) {
    for(var i=0;i&lt;100000;i++) {
        //dosomething
    }
    done(i);
}
startOperation(finished);</code></pre>
      </section>
      <section>
        <h4>You've Seen Callback Functions Before</h4>
        <pre class="fragment"><code>$('#elem').on('click', function() {
  //this anonymous function is a callback
})
$(document).ready(function() {
  //as is this
})
</code></pre>
      <pre class="fragment"><code>function clickHandler() {
  //do the event handling here
}
$('#elem').on('click', clickHandler);</code></pre>
      </section>
<!-- PROMISES/ARROWS/FETCH -->
      <section>
        <h2>Promises, Promises</h2>
        <p><small>A Promise object represents a value that may not be available yet, but will be resolved at some point in the future. Essentially, the promise is an object that represents the result of an operation, whenever it occurs. This allows us to write more flexible asynchronous code than simply passing callback functions to asynchronous functions.</small></p>
        <ul>
          <li class="fragment">Eliminate "callback hell" and write clean code.</li>
          <li class="fragment">Decouple from event-driven structures.</li>
          <li class="fragment">Chain <em>thenable</em> statements for readable structure.</li>
        </ul>
      </section>
      <section>
        <h2>Promise Example</h2>
        <pre class="fragment"><code>order('Shack Burger')
  .then(function(order) { //order = returned val from order
    finishedOrder = order.prepare()
    return finishedOrder //pass this down the chain
  })
  .then(function(food) { //food = returned val from last then
    serve(food)
  })
  .catch(function(err) {
    console.log("oops")
  }) //where have we seen this pattern?</code></pre>
      <pre class="fragment"><code>$.get(uri)
  .done(function(data) {
    console.log("success!");
  })
  .fail(function(err) {
    console.log('oops!');
  })</code></pre>
      </section>
<!-- END PROMISES/ARROWS/FETCH -->
<section>
        <h2>Node Server Lab</h2>
        <p>Create a script that launches a server and responds to three different routes.</p>
      </section>
      <section>
        <h2>Making An API</h2>
        <small>
        <ul>
          <li>Use Node and Express to create a solar system API.
            <ul>
              <li>GET /planets - return planets in solar system</li>
              <li>GET /solarsystem - return all bodies in solar system</li>
              <li>POST /includepluto - take a true/false value to determine whether Pluto is included in the /planets response</li>
            </ul>
          </li>
          <li>Create an HTML and jQuery page to consume the API. You can use jQuery or fetch().</li>
          <li>Bonus: Use handlebars to template the client page.</li>
        </ul>
        </small>
      </section>
