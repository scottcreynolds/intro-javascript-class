<!doctype html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!--    intro-->
      <section class="center">
        <h2>Introduction to JavaScript</h2>
        <h4>Advanced JavaScript</h4>
      </section>
<!-- OBJECTS -->
<section>
        <h4>Constructor Functions</h4>
        <p>The real power of objects is in the ability to define them generically and reuse them, such as the <code>Date</code> object.</p>
        <pre><code>// by convention, constructor functions are upper case
function Car(color, make, model, doors){
  this.color = color; // this = the instance when new is used
  this.make = make;
  this.model = model;
  this.doors = doors;
  this.engine = ""; // define something to be assigned later
  this.start = function() {
    console.log("vroom");
  }
}
var corvette = new Car("Red", "Chevy", "Corvette", 2);
console.log(corvette);
corvette.start();</code></pre>
      <aside class="notes">new makes it special, not the function. Regular function. Why? a function is an object. We'll come back to it.</aside>
      </section>
      <section>
        <h4>Object Lab</h4>
        <ul>
          <li>Use a constructor function to define a <code>Book</code> object with properties Title and Author.</li>
          <li>Define a <code>Bookworm</code> object with a Name and a collection of books that the bookworm wants to read.</li>
          <li>Add a method to the Bookworm to print all the book titles they want to read.</li>
          <li>Prompt for the Bookworm's name, then instantiate a new Bookworm object and assign 3 books.</li>
          <li>Call the method to print the list of book titles to read.</li>
        </ul>
      </section>
      <section>
        <h4>Object Lab Solution</h4>
        <pre><code>function Book(title, author) {
  this.title = title;
  this.author = author;
}
function Bookworm(name) {
  this.name = name;
  this.bookList = [];
  this.printBooks = function() {
    for(let i=0;i&lt;this.bookList.length;i++) {
      console.log(this.bookList[i].title);
    }
  }
}

let bookworm = new Bookworm(prompt("What is your name?"));
bookworm.bookList.push(new Book("1984", "George Orwell"));
bookworm.bookList.push(new Book("Choke", "Pahlaniuk"));
bookworm.printBooks();
        </code></pre>
      </section>
<!-- PROMISES/ARROWS/FETCH -->
      <section>
        <h2>Promises, Promises</h2>
        <p><small>A Promise object represents a value that may not be available yet, but will be resolved at some point in the future. Essentially, the promise is an object that represents the result of an operation, whenever it occurs. This allows us to write more flexible asynchronous code than simply passing callback functions to asynchronous functions.</small></p>
        <ul>
          <li class="fragment">Eliminate "callback hell" and write clean code.</li>
          <li class="fragment">Decouple from event-driven structures.</li>
          <li class="fragment">Chain <em>thenable</em> statements for readable structure.</li>
        </ul>
      </section>
      <section>
        <h2>Promise Example</h2>
        <pre class="fragment"><code>order('Shack Burger')
  .then(function(order) { //order = returned val from order
    finishedOrder = order.prepare()
    return finishedOrder //pass this down the chain
  })
  .then(function(food) { //food = returned val from last then
    serve(food)
  })
  .catch(function(err) {
    console.log("oops")
  }) //where have we seen this pattern?</code></pre>
      <pre class="fragment"><code>$.get(uri)
  .done(function(data) {
    console.log("success!");
  })
  .fail(function(err) {
    console.log('oops!');
  })</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <p><small>Arrow functions are an ES6 feature that provides a new syntax and some new behavior to JavaScript functions.</small></p>
        <pre class="fragment"><code>var arrowFunction = () => {
  console.log('I was called!')
}

var regularFunction = function() {
  console.log('I was called, too!')
}

arrowFunction() // 'I was called!'
regularFunction() // 'I was called, too!'</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <h4>Arguments</h4>
        <pre class="fragment"><code>var arrowFunction = (arg1, arg2) => {
  console.log(arg1, arg2)
}

arrowFunction('Hey,', 'you!') // 'Hey, you!'

//if only one arg, you can leave off the parens
var singleArgFunction = arg1 => {
  console.log(arg1)
}

singleArgFunction("hi!")</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <h4>Implicit Return</h4>
        <pre class="fragment"><code>function square(x) {
  return x*x;
}

var arrowSquare = n => n*n
//only with no body block

square(4) // 16
arrowSquare(4) // 16</code></pre>
      </section>
      <section>
        <h2>Arrow Functions</h2>
        <pre class="fragment"><code>order('Shack Burger')
  .then(function(order) { //order = returned val from order
    finishedOrder = order.prepare()
    return finishedOrder //pass this down the chain
  })
  .then(function(food) { //food = returned val from last then
    serve(food)
  })
  .catch(function(err) {
    console.log("oops")
  })</code></pre>
  <pre class="fragment"><code>order('Shack Burger')
  .then(order => order.prepare()) //implicit return
  .then(food => serve(food))
  .catch(err => { console.log("oops") })</code></pre>
      </section>
      <section>
        <h2>Putting it Together</h2>
        <pre class="fragment"><code>fetch('https://api.github.com/repos/jquery/jquery/commits')
  .then(resp => resp.json())
  .then(json => console.log(json));</code></pre>
      </section>
      <section>
        <h2>Fetch API</h2>
        <code>fetch('https://api.github.com/repos/jquery/jquery/commits')
  .then(resp => resp.json())
  .then(json => console.log(json));</code></pre>
        <small><ul>
          <li class="fragment">Built from the ground up to handle modern web needs, like JSON and streaming.</li>
          <li class="fragment"><code>fetch()</code>is a global function. No making XHR objects.</li>
          <li class="fragment">Promise-based.</li>
          <li class="fragment">Body <em>mixin</em> provides parsing.</li>
          <li class="fragment">Not supported in IE OF COURSE BECAUSE WHY HAVE NICE THINGS</li>
        </ul></small>
      </section>
      <section>
        <h2>Authenticated Fetch</h2>
        <pre class="fragment"><code>const token = 'YOUR_TOKEN_HERE'
fetch('https://api.github.com/user/repos', {
  headers: {
    Authorization: `token ${token}`
  }
}).then(res => res.json()).then(json => console.log(json));</code></pre>
      </section>
<!-- END PROMISES/ARROWS/FETCH -->
<!-- EXPRESS ADVANCED -->
      <section>
        <h2>Router and Controllers</h2>
      </section>
      <section>
        <h2>Databases with Mongoose</h2>
      </section>
<!-- END EXPRESS ADVANCED -->
      <section>
        <h2>Handlebars</h2>
      </section>
      <section>
        <h2>Closures</h2>
      </section>
      <section>
        <h2>Map/Reduce</h2>
      </section>
      <section>
        <h1>Prototypal JavaScript</h1>
      </section>
      <section>
        <h1>Prototypes in Action</h1>reverse string
      </section>
       <section>
        <h2>Hoisting</h2>
        <p>Hoisting is a fancy way of saying that JavaScript will move function and variable declarations to the top of their scope before code execution.</p>
        <p class="fragment"><em>Declarations</em>, not assignments</p>
        <pre class="fragment"><code>//when we write
var x = 0;
//javascript sees
var x;
x = 0;</code></pre>
      </section>
      <section>
        <h2>Hoisting</h2>
        <pre class="fragment"><code>console.log(hoisted); //what happens?</code></pre>
        <pre class="fragment"><code>console.log(hoisted);

var hoisted = "hi"; //what happens?</code></pre>
        <pre class="fragment"><code>var hoisted; //declaration hoisted to top of scope
console.log(hoisted);
hoisted = "hi";</code></pre>
<pre class="fragment"><code>function myFunction(){
  console.log(word)
  var word = "cake";
}//what happens when we myFunction()?</code></pre>
      <aside class="notes">remind function scope</aside>
      </section>
      <section>
        <h2>Function Hoisting</h2>
        <pre class="fragment"><code>eat();

function eat(){
  console.log("time to eat cake!")
} //whole function hoisted</code></pre>
      <pre class="fragment"><code>eat();

var eat = function() {
  console.log("time to eat cake!")
}</code></pre>
      </section>
      <section>
        <h2>Hoisting Danger</h2>
        <pre class="fragment"><code>var snack = "granola bar";
function eat(){
  console.log(snack);
  var snack = "snickers";
}
eat();</code></pre>
        <p class="fragment">Most problems can be avoided by using good naming and good organization practices, and <code>let</code> and <code>const</code> rather than <code>var</code></p>
        <aside class="notes">it re-declared var.</aside>
      </section>
      <section>
        <h1>This</h1>
      </section>
      <section>
        <h2>Call/Apply</h2>
      </section>
      <section>
        <h2>js console in chrome https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference</h2>
      </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      history: true,
      center: false,

      // More info https://github.com/hakimel/reveal.js#dependencies
      dependencies: [{
          src: 'plugin/markdown/marked.js'
        },
        {
          src: 'plugin/markdown/markdown.js'
        },
        {
          src: 'plugin/notes/notes.js',
          async: true
        },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function() {
            hljs.initHighlightingOnLoad();
          }
        }
      ]
    });
  </script>
</body>
</html>
